===Welcome to the===

==Parsing Expression Grammar Template Library==

  "Don't Parse" -- Dan J. Bernstein


=Introduction=

The Parsing Expression Grammar Template Library (PEGTL) is a C++0x library for creating parsers according to a Parsing Expression Grammar (PEG).
Grammars are embedded as regular C++ code, and consist of template hierarchies of classes.
These hierarchies naturally correspond naturally to the inductive definitions of PEGs.
The library extends on the subject of PEGs with new expression types, and mechanisms to ensure helpful diagnostics in case of parsing errors.
PEGs are similar to Context-Free Grammars (CFGs); for a description see [http://en.wikipedia.org/wiki/Parsing_expression_grammar Wikipedia page on PEGs] or this [http://pdos.csail.mit.edu/~baford/packrat/popl04/peg-popl04.pdf paper on PEGs].

===Status===

PEGTL version 0.17 is ready, and should work "just fine"; this version adds support for parsing ranges of input iterators with automatic minimal buffering for back-tracking.

*Features*

  * Comprehensive set of parsing rules.
  * Produces very efficient parsers.
  * Arbitrary user-defined parser state.
  * User-defined input abstractions, supplied:
    # files via mmap(2),
    # strings (and files in strings),
    # ranges of forward iterators, and
    # input iterators, w/automatic minimal buffering.
  * User-defined debug abstractions, supplied:
    # no diagnostics,
    # diagnostics on error,
    # two-pass combination,
    # on error plus complete trace of all rule invocations.
  * Expressions/rules and actions embedded in simple C++ code.
  * Diagnostics with (nearly-)pretty-printing of grammar rules.
  * User-defined logging of diagnostic messages, defaults to cerr.
  * (Some grammar optimisations and checks at compile-time.)
  * Examples, inluding PEGTL grammar for [http://www.r6rs.org/ R6RS] Scheme syntax.

*Compared to Context-Free Grammars*

  * Strictly greater expressive power.
  * Strictly deterministic, no ambiguities.
  * Tokeniser subsumed by parser, no separate step required.

===Audience===

The PEGs should be easy to learn and apply by anyone experienced with formal languages, in particular context-free grammars (CFG) and their representation in Backus-Naur form (BNF, EBNF).
The PEGTL can be used to effectively create efficient and powerful parsers in C++0x.
The reader should be comfortable with CFGs, (E)BNF and/or PEGs, and have a reasonable understanding of C++ templates and related compiler messages.

===Limitations===

This documentation is a bit scanty, it will be significantly extended once the core functionality of the library stabilises significantly as to not require constant rewriting.

The PEGTL inherits the general limitation of PEGs of not being able to use left-recursive rules.
More generally, any recursion/iteration that can recurse/iterate without making progress, i.e. without consuming any input, *must* be avoided.
With a little exercise, it is easy to recognise, and rewrite, grammars that exhibit this problem.

The PEGTL uses compile-time polymorphism (i.e. templates; rather than run-time polymorphism, i.e. interface classes and virtual functions) where grammars are created mainly by instantiating appropriate class templates.
It might therefore not be well suited for applications that create and/or change grammars at run-time.

The PEGTL currently has explicit support ASCII input data only.
Support for UTF-8 and raw binary data is likely to be included in the near future.
Other character sets and encodings will probably never be supported.

The support for input iterators currently gives error positions in byte offsets (all other input classes produce line and column numbers).
This will probably be fixed in the near future.

===Requirements===

The PEGTL uses some C++0x features and requires GCC 4.3 with `-std=gnu++0x` to compile.
It was developed under Mac OS X, but should work on any Linux or Unix system:
Only headers and libraries from GCC 4.3 and the SUSv3 standard are used.

===Installation===

The latest PEGTL distribution is available from the [http://code.google.com/p/pegtl/downloads/list "Downloads"] section of the Google Code [http://code.google.com/p/pegtl project home page].
PEGTL is a header-only library that neither requires any compilation during installation, nor creates any library for applications to link against.
To install, the directory `include/pegtl` must be copied to your projects' directory of include files, a dedicated directory like `/usr/include/`, or any other location that is appropriate.

For projects using the PEGTL, it must be ensured that a suitable compiler is used, and that the directory with the PEGTL header files is in the include search path.
For recommended compiler switches see the `Makefile` included in the PEGTL distribution archive; if a project using the PEGTL compiles, it can be reasonably assumed to function correctly.

It is highly recommended to check the `Makefile`, and to change the compiler flags to whatever is used in your projects, and to run `make`, which also runs the unit-tets.


=Tutorial=

This tutorial covers basic use cases of the PEGTL: how to use the provided facilities to parse an input, and how to perform user-defined actions while doing so.

===Basic Concepts===

The PEGTL is built around the concepts of _rule_, _input_, and _debug_, three kinds of classes with dedicated roles.

_Rules_ are classes that represent grammar expressions.
The PEGTL provides _rules_ for all PEG operations, plus atomic _rules_ for characters, strings, some character classes, and some convenience _rules_.
Atomic _rules_ can be directly used, or atomic and user-defined _rules_ can be used to inductively build _rules_ for arbitrary grammars.

The _input_ classes are wrappers around data sources from which the PEGTL reads during parsing.
The _debug_ classes determine if, when, and how to generate diagnostic messages.

For the _debug_ there is currently a choice of three classes defined in `pegtl_parse.hh` and `pegtl_debug.hh`.

  # Class `pegtl::dummy_debug` does not produce any diagnostic messages.
  # Class `pegtl::basic_debug` generates diagnostic messages in case of error.
  # Class `pegtl::trace_debug` generates diagnostic messages for every rule invocation.

Note that class `pegtl::trace_debug` has a run-time flag to disable trace messages, in which case it falls back to the behaviour of class `pegtl::basic_debug`.

The main PEGTL `parse()` function requires a _rule_, an _input_, and a _debug_ to perform.
There are also front-end functions to `parse()` that only take the _rule_ as template argument, and automatically handle _input_ and _debug_.

Further on, the _rules_ of a grammar will be extended by _state_ and _actions_ in order to make a parser do more than return a Boolean 'success' flag.

===First Example===

As first example consider the _rule_ `first` provided in `example/first.cc`.

{{{
namespace example
{
   using namespace pegtl;

   struct first
         : seq< alpha, until< sor< alpha, digit >, eol > > {};
}
}}}

The rules `alpha` and `digit` are provided and accept a single ASCII letter, or digit, respectively.
The `seq` template stands for concatenation, `sor` for ordered choice; `until` requires the first rule, `sor< alpha, digit >`, to match until `eol`, end-of-line or end-of-file, is reached.
The _rule_ can be read as "an alpha, followed by zero-or-more characters that can be either alphas or digits", i.e. the regular expression "[a-zA-Z][a-zA-Z0-9]*".

Note that the rule `first` could also be defined as a `typedef`, rather than a `struct`, i.e. as `typedef seq< alpha, until< sor< alpha, digit >, eol > > first;`.
For the resulting grammar there is no difference whether a `typedef` or a `struct` is used.
However it is recommended to _not_ use `typedef` because the PEGTL uses the name of the `struct` in diagnostic messages, which can enhance readability.

The easiest way to do some actual parsing is by calling one of the `parse` front-end functions with two strings as argument.
In this example the function is `basic_parse_string_nothrow()` which uses a `basic_debug` for diagnostic purposes (see below), and takes (at least) one argument, a string `s` with the input to the parser.
The _rule_ is, by necessity, a template argument to `basic_parse_string_nothrow()`.

{{{
int main( int argc, char ** argv )
{
   for ( int i = 1; i < argc; ++i ) {
      basic_parse_string_nothrow< example::first >( argv[ i ] );
   }
   return 0;
}
}}}

The return value of `basic_parse_string_nothrow()` indicates whether parsing was successful.
In the case of failure, diagnostic messages are printed to `std::cerr`.
Alternatively the function `basic_parse_string_throws()` could have been used; in the case of failure it throws an exception.

===State and Actions===

The _parser_ functions use variadic templates to accept arbitrary additional arguments that are, in general, passed recursively from _rule_ invocation to _rule_ invocation.
These arguments are the additional _state_ of the parser that can be created, modifyied, or replaced by appropriate user-defined _actions_:
Which purpose the _state_ serves depends only on the _actions_ embedded in the grammar.

An _action_ is a function that, in the definition of the grammar in the C++ source, is associated with a _rule_.
Every time the _rule_ succeeds, the action is invoked with the portion of the _input_ that matched the _rule_.

Some typical use cases for _state_ and _actions_ are

  * _actions_ that generate some kind of abstract syntax tree (AST) as _state_, that is further processed separately, after the parser has finished its job, or
  * specific tasks performed while parsing, like in the included `calculator.cc` where the expressions are evaluted by the parser "on the fly" using _actions_.

An _action_ is attached to a rule by using the `action` class template that takes two template arguments.
The first argument is a _rule_, the second argument is the _action_, which must be a class providing a static `matched` function declared as follows

{{{
   struct my_action
   {
      static void matched( const std::string & token, ... );
   };
}}}

where the first string argument contains the portion of the input that the rule attached to the action matched, and the actually used _state_ must be substituted for the `...`.

For example, the included `calculator.cc` uses a `std::vector< int >` as stack for the evaluation of (arbitrarily nested) arithmetic expressions.
Whenever the parser recognises (the string representation of) a number, it pushes the number onto the evaluation stack.

{{{
   struct push_action
   {
      template< typename Stack >
      static void matched( const std::string & m, Stack & s )
      {
         s.push_back( utility::string_to_signed< typename Stack::value_type >( m ) );
      }
   };

   struct read_number
         : seq< opt< list< '+', '-' > >, plus< digit > > {};

   struct push_number
         : pad< action_all< read_number, push_action >, space > {};
}}}

Struct `push_action` is the user-defined action that converts the given string to an integer, and pushes it onto the supplied stack.
Struct `read_number` is a normal _rule_ that recognises decimal numbers with optional sign.
Struct `push_number` contains `action< read_number, push_action >`, which invokes `push_action::matched` every time that `read_number` matched.

The included file `example/sexpression.cc` shows some further examples.

===Parser Input===

Most examples parse data given as `std::string`, possibly obtained from a file via `pegtl::read_string()`.
The `scheme.cc` example shows how to use the `buffer_input` class to parse files (or, more generally: ranges of input iterators) without the need of buffering the whole input in a container first.
This allows the parsing of files etc. that do not fit into memory.

===Error Messages===

When an error occurs during parsing, i.e. the parser fails for the given input, a parser using the `basic_debug` or `trace_debug` classes as _debug_ will print a backtrace of which rules it was attempting to match at which positions.
Here is the output from the first example program invoked with the -- illegal, since it recognises the regex `[a-zA-Z][a-zA-Z0-9]*` -- input `abc%`.

{{{
  > ./first "abc%"
  pegtl: syntax error at line=1 column=4
  pegtl: nesting # 4 at line=1 column=4 rule digit
  pegtl: nesting # 3 at line=1 column=4 rule ( alpha / digit )
  pegtl: nesting # 2 at line=1 column=2 rule ( ( alpha / digit ) % pegtl::eol )
  pegtl: nesting # 1 at line=1 column=1 rule example::first === ( alpha ( ( alpha / digit ) % pegtl::eol ) )
  pegtl: parsing input from command line argument aborted
  pegtl: parsing aborted at line=1 column=4
}}}

The first line indicates that there was a syntax error, and where the error occurred.
The next line shows the innermost rule that the parser was attempting to match, i.e. the rule where the error was detected, here `digit`.
The following lines show every step of the inductive definition up to the top-level rule, which in this case is `example::first`.
The final two lines show where the error occurred, including where the input came from in the first place, which can be a filename, or, like here, a command line argument.

Rules in error messages are printed in one of two distinct formats, which can be either only the actual expression like `digit`, or `( ( alpha / digit ) % pegtl::eol )`.
Or, the name of the rule class is printed first, followed by `===`, and the actual expression.
The PEGTL automatically collects the name of a rule when the rule was defined as a `struct`, rather than a `typedef`.
Normal rule names include their namespace.

There is also a mechanism that can be used to manually set the name of a rule to an arbitrary value.
This mechanism is used with the PEGTL to give rules like `digit` or `eol` their short names, and is documented in the "Advanced" section below.

=Expressions=

This table shows the principal PEGTL expressions, and their symbolic representation.
The simple rules should be self explaining, the combinators are explained in greater detail below.

|| *Expression* || *Basic Rules* || *Description* ||
|| || `eof` || Matches end-of-file. ||
|| || `failure` || Always fails. ||
|| || `success` || Always succeeds. ||
|| `R?` || `opt< R >` || "Optional" ||
|| `R*` || `star< R >` || "Repeat zero-or-more" ||
|| `R+` || `plus< R >` || "Repeat one-or-more" ||
|| `C@` || `until< C >` || PEGTL convenience extension. ||
|| `&C` || `at< C >` || "And-predicate" ||
|| `!C` || `not_at< C >` || "Not-predicate" ||
|| `R T` || `seq< R, T >` || Sequence, or concatenation (variadic). ||
|| `R / T` || `sor< R, T >` || Ordered choice, or sequenced-or (variadic). ||
|| `R % C` || `until< R, C >` || PEGTL convenience extension. ||
|| `R{n}` || `rep< R, n >` || Repeat exactly `n` times" ||
|| `C --> R` || `ifthen< C, R >` || PEGTL convenience extension. ||
|| `C ->> R` || `ifmust< C, R >` || PEGTL convenience extension. ||
|| || `ifthenelse< C, R, T >` || PEGTL convenience extension. ||
|| || `ifmustelse< C, R, T >` || PEGTL convenience extension. ||
|| || `pad< T, L, R = L >` || PEGTL convenience extension. ||
|| *Expression* || *String Rules* || *Description* ||
|| `.` || `any` || Match any character. ||
|| `"a"` || `one< 'a' >` || Match character. ||
|| `[^a]` || `not_one< 'a' >` || Match any other character. ||
|| `[az]` || `list< 'a', 'z' >` || Match character in list. ||
|| `[^az]` || `not_list< 'a', 'z' >` || Match character not in list. ||
|| `[a-z]` || `range< 'a', 'z' >` || Match character in range. ||
|| `[^a-z]` || `not_range< 'a', 'z' >` || Match character not in range. ||
|| `"hallo"` || `string< 'h', 'a', 'l', 'l', 'o' >` || Match character sequence. ||
|| `"\n` || `lf` || Single line-feed. ||
|| `"\r"` || `cr` || Single carriage-return. ||
|| `"\r\n"` || `crlf` || Combined carriage-return and line-feed. ||
|| `$` || `eol` || Match any end-of-line, including end-of-file. ||
|| `[[:blank:]]` || `blank` || Match space or tab. ||
|| `[[:space:]]` || `space` || Match any white-space. ||
|| `[[:digit:]]` || `digit` || Match any decimal digit. ||
|| `[[:lower:]]` || `lower` || Match any lower-case letter. ||
|| `[[:upper:]]` || `upper` || Match any upper-case letter. ||
|| `[[:alpha:]]` || `alpha` || Match any upper- or lower-case letter. ||
|| `[[:alnum:]]` || `alnum` || Match any upper- or lower-case letter or digit. ||
|| `[[:xdigit:]]` || `xdigit` || Match any hexadecimal digit, upper- or lower-case. ||
|| || `identifier` || Match a C-language identifier (alpha and digits and underscores, no leading digit). ||
|| *Expression* || *Action Rules* || *Description* ||
|| || `action_all< R, F >` || On success of `R`, call `F` with matched input and all _state_ objects. ||
|| || `action_nth< N, R, F >` || On success of `R`, call `F` with matched input and N-1-st _state_ object. ||

Note that the Posix syntax for extended regular expressions is used for the character classes in square brackets.

Note that the current implementation of the string rules only works correctly with ASCII.

=Combinators=

Combinators, or operators, are rules that build new expressions from their argument expressions.

===opt< Rule >===

The `opt` template makes `Rule` optional, and therefore always succeeds.

===star< Rule >===

The `star` template repeatedly invokes `Rule` until it fails; the `star` itself always succeeds.

===plus< Rule >===

Semantically equivalent to `seq< Rule, star< Rule > >`.

===sor< Rule, ... >===

The `sor` variadic template can be instantiated with arbitrary many template parameters, including 0 or 1.
It invokes its arguments in order until the first one succeeds, in which case it succeeds itself, or fails if none of the arguments succeed.

This is very much _unlike_ context-free grammars, where the choice combinator is non-deterministic.

===seq< Rule, ... >===

The `seq` variadic template can be instantiated with arbitrary many template parameters, including 0 or 1.
It invokes its arguments in order until the first one fails, in which case it fails itself, or succeeds if all of the arguments succeed.

===at< Rule >===

The `at` template invokes `Rule` and returns its return value, but rewinds the input, i.e. `at` never consumes any input.

===not_at< Rule >===

The `not_at` template invokes `Rule` and returns the negative of its return value, and rewinds the input, i.e. `not_at` never consumes any input.

===must< Rule >===

The `must` template invokes `Rule` and stops the parser when `Rule` fails, even when in an optional context, e.g. `opt< must< Rule > >` or `star< must< Rule > >` both stop the parser when `Rule` fails.

===until1< Cond >===

Semantically equivalent to the recursive `Rule = sor< Cond, seq< any, Rule > >`, but implemented without recursion.

===until< What, Cond >===

Semantically equivalent to the recursive `Rule = sor< Cond, seq< What, Rule > >`, but implemented without recursion.

===rep< Rule, Number >===

Semantically equivalent to `seq< Rule, ..., Rule >` with `Number` repetitions of `Rule`.

===ifthen< Cond, Then >===

Semantically equivalent to `sor< seq< Cond, Then >, not_at< Cond > >`, except for invoking `Cond` only once.

===ifmust< Cond, Then >===

Semantically equivalent to `seq< Cond, must< Then > >`.

===ifthenelse< Cond, Then, Else >===

Semantically equivalent to `sor< seq< Cond, Then >, seq< not_at< Cond >, Else > >`, except for invoking `Cond` only once.

===ifmustelse< Cond, Then, Else >===

Semantically equivalent to `sor< seq< Cond, must< Then > >, seq< not_at< Cond >, must< Else > > >`, except for invoking `Cond` only once.

===pad< Rule, PadL, PadR >===

Semantically equivalent to `seq< star< PadL >, Rule, star< PadR > >`; the `PadR` template argument defaults to `PadL`.

===action< Rule, Func >===

Semantically equivalent to `Rule` with respect to parsing, however on success of `Rule` invokes the static class function `Func::matched( const std::string &, ??? )` with the portion of the input that matched `Rule` as first argument, and forwards any _state_ that was passed to `action` as further arguments. (As in the whole library, C++0x variadic templates and rvalue-references are used to achieve "perfect forwarding" of the _state_ to `Func::matched`.)


=Advanced=

This section covers advanced topics and library internals.

===Anatomy===

A rule class currently must contain three things.

  # A typedef named `key_type`.
  # A static function named `s_insert()`.
  # A static function named `s_match()`.

The `s_match()` function is the actual parsing function, the `key_type` and `s_insert()` members are to initialise the rule pretty-printer.

The pretty-printer contains a map from rules to rule names and pretty-printed rules.
The mangled class name of a rule is used as key to find the corresponding entry at run-time.
The `key_type` typedef adds a layer of indirection, i.e. `typeid( rule::key_type ).name()` is used instead of `typeid( rule ).name()`, which allows classes to camouflage as other rules.
This is useful for classes that do more than plain parsing, but who's parsing behaviour is equivalent to some other rule, see for example class `pegtl::action`.

The `s_insert()` function is responsible for inserting an appropriate entry to the run-time map of the pretty-printer.
The details are not straight-forward and will be documented later.

The `s_match()` function is the actual parsing function, in text-book recursive-descent parser style.
The return value signals whether the rule succeeded; alternatively an exception can be thrown to signal failure.
In case of failure, a rule's `s_match()` function *must not* consume any input; helper classes like `pegtl::marker` and `pegtl::character` support this.
These and other details should be rather straight-forward and reasonably easy to pick up from looking at the existing parsing rule classes in `parse_generic.hh` and `parse_string.hh`.

===Examples===

The PEGTL distribution archive contains C++ implementation files that were used during development and debugging of the library itself.
They are included in order to serve as advanced examples on how to create grammars, and in particular how to perform actions while parsing.

===Optimisations===

The PEGTL contains some specialisations of the class templates of its rules that optimise some simple redundancies in the grammar.
For example, `at< at< Rule > >` is transformed into the equivalent `at< Rule >`.

When the macro PEGTL_IMPURE_OPTIMISATIONS is defined, additional template specialisations are enabled that perform optimisations on a grammar that are not always "safe" in the following sense.
The optimisations elide rule invocations that are not necessary for the decision of whether the parser succeeds for any given input.
However, if these rules perform additional operations on the parser state, or have global side-effects, the behaviour will be different compared to the non-optimised version.

For example, `at< star< Rule > >` always succeeds, and can therefore be transformed into `success`; however `at< star< Rule > >` will invoke `Rule` at least once, while `success` will never invoke `Rule`.
The macro can be defined by adding `-DPEGTL_IMPURE_OPTIMISATIONS` to the compiler flags, by changing `pegtl.hh`, or by defining it in the code that includes `pegtl.hh` before the corresponding include preprocessor directive.

===Recursion===

Every rule invocation consists of a function call.
The PEGTL often uses guard-objects in its implementation, which is good C++ style, but unfortunately prevents tail-calls from being optimised.
To prevent a stack overflow, grammars should prefer to use rules for iteration, rather than recursive rules, wherever possible.

This means, in particular, to avoid "head and tail"-style recursion which is used in many functional programming languages.
For example, to express that a `foo` is either empty, or a `bar` followed by a `foo`, we could write the grammar as follows.

{{{
   struct foo
   	 : sor< eof, seq< bar, foo > > {};
}}}

Here every recursive call of `foo` creates a new stack-frame.
A better, equivalent, expression is the following.

{{{
   struct foo
         : until< bar, eof > {};
}}}


===Changelog===

*PEGTL version 0.18*

  * Added parser functions `*parse_forward*` for forward iterators (completeness).
  * Renamed parser functions for input iterators to `*parse_input*` (consistency).
  * Added parser functions `*parse_file*` for files, implemented with mmap(2) (necessity).
  * Added initial support for customised logging of error messages (flexibility).

*PEGTL version 0.17*

  * Added support for ranges of input iterators with automatic minimal buffering (flexibility).

*PEGTL version 0.16*

  * Added class `action_nth` (flexibility).
  * Renamed class `action` to `action_all` (consistency).
  * Changed class `marker` to a nop when "must" is true (performance).
  * Changed `dummy_debug` to interpret "must" tracking (consistency).
  * Fixed typo in name of `PEGTL_IMPURE_OPTIMISATIONS` macro (correctness).
  * Made the marker class a sub-class of the _input_ class (simplicity).
  * Renamed some of classes named `*white*`, `*space*`, or `*blank*` (consistency).
  * Fixed some issues in the R6RS example (CFG to PEG mismatch, only first datum).
  * Added missing template arguments to `smart_parse_*` functions (correctness).

*PEGTL version 0.15*

  * Removed some small superfluous functions (less is more).
  * Changed the "must" tracking from run-time to compile-time (better?).

*PEGTL version 0.14*

  * Optimised behaviour of seq<> and string<> (performance).
  * Added detection of division-by-zero to calculator example.
  * Removed data source debug tracking from the library (simplicity).
  * Removed run-time limits on rule applications and nesting (simplicity).
  * Disentangled a couple of header files (maintainability).
  * Renamed class iterator_input to forward_input (consistency).
  * Added class string_input to initialise forward_input from a string (convenience).
  * Removed template argument Rule to action functor's matched() method (simplicity).

*PEGTL version 0.13*

  * Added more wrapper functions for parsing (convenience).
  * Renamed existing wrapper functions for parsing (consistency).
  * Added `rewind()` method to class `iterator_input` (indirect).

*PEGTL version 0.12*

  * Added more directory structure.
  * Fixed compile-error in `sexpression.cc` (correctness).

*PEGTL version 0.11*

  * Fixed back-tracking in class `string` (*correctness*).
  * Fixed order of operands in calculator example (correctness).

*PEGTL version 0.10*

  * Added Scheme [http://www.r6rs.org/ R6RS] grammar.
  * Fixed behaviour at end-of-input (aesthetics).
  * Fixed behaviour and use of class `position` (*correctness*).
  * Changed to lazy initialisation of pretty-printer (performance).
  * Changed the design of the input and parser classes (flexibility).
  * Changed how expression rules provide their printer key (simplicity).

*PEGTL version 0.9*

  * Changelog starts with PEGTL version 0.9.

===Thank You===

  * Christopher Diggins and the [http://yard-parser.sourceforge.net YARD parser].
  * Stephan Beal, for the bug reports, suggestions and discussions.


=License=

Copyright (c) 2008 Dr. Colin Hirsch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
