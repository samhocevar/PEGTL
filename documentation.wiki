===Welcome to the===

==Parsing Expression Grammar Template Library==

  "Don't Parse" -- Dan J. Bernstein


=Introduction=

The Parsing Expression Grammar Template Library (PEGTL) is a C++ library for creating parsers according to a Parsing Expression Grammar (PEG).
Grammars are embedded as regular C++ code, and consist of hierarchies of (templated) classes.
These class hierarchies naturally correspond to the inductive definitions of PEGs.
The library extends on the subject of PEGs with new expression types, and mechanisms to ensure helpful diagnostics in case of parsing errors.
PEGs are similar to Context-Free Grammars (CFGs); for a description see [http://en.wikipedia.org/wiki/Parsing_expression_grammar Wikipedia page on PEGs] or this [http://pdos.csail.mit.edu/~baford/packrat/popl04/peg-popl04.pdf paper on PEGs].
The PEGTL is heavily inspired by the [http://yard-parser.sourceforge.net YARD parser].

===Status===

*Features*

  * Comprehensive set of parsing rules.
  * Produces very efficient parsers.
  * Customisable input abstraction.
  * Arbitrary user-defined parser state.
  * User-defined input abstraction, supplied:
    # files,
    # strings,
    # command line arguments,
    # iterator ranges.
  * User-defined debug abstraction, supplied:
    # no diagnostics,
    # diagnostics on error,
    # on error plus complete trace of all rule invocations.
  * Expressions/rules and actions embedded in simple C++ code.
  * Detects some invalid grammars at compile-time.
  * Optimises some redundancies in the grammar at compile-time.
  * Diagnostics with (nearly-)pretty-printing of grammar rules.
  * In general "better" thanks to using some C++0x features.
  * Example programs that show many of the PEGTL features.

*Compared to Context-Free Grammars*

  * Strictly greater expressive power.
  * Strictly deterministic, no ambiguities.
  * Tokeniser subsumed by parser, no separate step required.

===Audience===

The PEGs should be easy to learn and apply by anyone experienced with formal languages, in particular context-free grammars (CFG) and their representation in Backus-Naur form (BNF, EBNF).
The PEGTL can be used to effectively create efficient and powerful parsers in C++0x.

===Limitations===

The PEGTL inherits the general limitation of PEGs of not being able to use left-recursive rules.
More generally, any recursion/iteration that can recurse/iterate without making progress, i.e. without consuming any input, must be avoided.
With a little exercise it is however rather easy to recognise, and rewrite, grammars that exhibit this problem.

The PEGTL uses compile-time polymorphism (i.e. templates; rather than run-time polymorphism, i.e. interface classes and virtual functions) where grammars are created mainly by instantiating appropriate class templates.
It might therefore not be well suited for applications that create and/or change grammars at run-time.
Support for run-time polymorphism might be included in the future if required.

The PEGTL currently only handles ASCII input data.
Character sets/encodings compatible with ASCII that do _not_ use variable-length character encodings, e.g. ISO 8859-1, should work too.
Support for UTF-8 and raw binary data is likely to be included in the near future.
Other character sets and encodings will probably never be supported.

The PEGTL uses straight-forward back-tracking which reads parts of the input multiple times.
Currently it is not possible to use a PEGTL parser with an input iterator without buffering the whole input in a dedicated buffer, which is not very suitable for very large inputs.
Support for very large inputs might be included in the future.

===Requirements===

The PEGTL uses features from C++0x and requires GCC 4.3.0, or later, to compile.
It was developed under Mac OS X, but should work on any Linux or Unix system.
Only headers and libraries defined in the C99, C++0x, and SUSv3 standards are used.

===Installation===

The latest PEGTL distribution is available from the [http://code.google.com/p/pegtl/downloads/list "Downloads"] section of the Google Code [http://code.google.com/p/pegtl project home page].
PEGTL is a header-only library that neither requires any compilation during installation, nor creates any library for applications to link against.
To install, all header files must be copied to your projects' directory of include files, a dedicated directory like `/usr/local/pegtl/`, or any other location that is appropriate.

For projects using the PEGTL, it must be ensured that a suitable compiler is used, and that the directory with the PEGTL header files is in the include search path.
For recommended compiler switches see the `Makefile` included in the PEGTL distribution archive; if a project using the PEGTL compiles, it can be reasonably assumed to function correctly.

It is highly recommended to check the `Makefile`, and to change the compiler flags to whatever is used in your projects before invoking `make test` to run all unit tests.


=Tutorial=

This tutorial covers basic use cases of the PEGTL: how to use the provided facilities to parse an input, and how to perform user-defined actions while doing so.

===Basic Concepts===

A PEGTL _parser_ is a front-end class or function that ties together all that is required to actually parse something.
A parser needs a _rule_ that represents a grammar expression, an _input_ to parse, and a _debug_ that determines if, when and how to generate diagnostic messages.

All three of _rule_, _input_, and _debug_ are appropriate classes.
In this tutorial, only the provided _input_ and _debug_ classes will be used.

_Rules_ are classes that represent grammar expressions.
The PEGTL provides rules for all PEG operations, plus atomic rules for characters, strings, some character classes, and some convenience rules.
_Rules_ are combined to new _rules_ by specialising and/or instantiating the class templates that correspond to non-atomic parsing expressions.

Further on, the _rules_ of a grammar will be extended by _state_ and _actions_ in order to make a parser do more than return a bool: whether the input is recognised.

===First Example===

For example, consider the _rule_ `first` as provided in `first.cc`.

{{{
namespace example
{
   using namespace pegtl;

   struct first
         : seq< alpha, until< sor< alpha, digit >, eol > > {};
}
}}}

The rules `alpha` and `digit` are provided and accept a single ASCII letter, or digit, respectively.
The `seq` template concatenates expressions, `sor` is the ordered choice, and `until` requires the first rule, `sor< alpha, digit >`, to match until `eol`, end-of-line or end-of-file, is reached.
The _rule_ can be read as "an alpha, followed by zero-or-more characters that can be either alphas or digits", i.e. the regular expression "[a-zA-Z][a-zA-Z0-9]*".

Note that the rule `first` could also be defined as a `typedef`, rather than a `struct`, i.e. as `typedef seq< alpha, until< sor< alpha, digit >, eol > > first;`.
For the resulting grammar there is no difference whether a `typedef` or a `struct` is used.
However it is recommended to _not_ use `typedef` because the PEGTL uses the name of the `struct` in diagnostic messages, which can enhance readability.

===Actual Parsing===

Once _rule_ is defined, it can be used in conjunction with an _input_ and a _debug_ to actually parse something.
Currently one _input_ class `pegtl::input` is provided in `pegtl_input.hh`.
It can read from a file, a `std::string`, or an arbitrary iterator range of characters.

For the _debug_ there is currently a choice of three classes defined in `pegtl_parse.hh` and `pegtl_debug.hh`.

  # Class `pegtl::dummy_debug` does not produce any diagnostic messages.
  # Class `pegtl::basic_debug` generates diagnostic messages in case of error.
  # Class `pegtl::trace_debug` generates diagnostic messages for every rule invocation.

Note that class `pegtl::trace_debug` has a run-time flag to disable trace messages, in which case it falls back to the behaviour of class `pegtl::basic_debug`.

===First Example (cont'd)===

The easiest way to do some actual parsing is by calling one of the `parse` front-end functions with two strings as argument.
The first string is the input to the _parser_, the second string is used for diagnostic purposes only and should provide information as to where the first string was obtained from.
This might be a filename, a socket address, etc., or a command line argument as in the example below.

{{{
int main( int argc, char ** argv )
{
   for ( int i = 1; i < argc; ++i ) {
      parse< example::first >( argv[ i ], "command line argument" );
   }
   return 0;
}
}}}

The `parse` function internally creates an instance of class `pegtl::input` and, by default, uses a `basic_debug` in order to provide "sensible" error messages.
It is declared as follows.

{{{
   template< typename Rule, typename Debug = basic_debug, typename ... Class >
   bool parse( const std::string & input, const std::string & debug, Class && ... cl );
}}}

The return value indicates whether parsing was successful.
The optional arguments `Class && ... cl` are the _state_ of the parser, see below.

It is recommended to be familiar with rvalue references and variadic templates as required for "perfect forwarding" in [http://en.wikipedia.org/wiki/C%2B%2B0x C++0x].

===State and Actions===

A _parser_ can be invoked with arbitrary _state_ that is in general passed recursively from _rule_ invocation to _rule_ invocation.
User-defined _rules_ can use or change the _state_, create or replace it, or choose to not forward it to sub-ordinate _rules_.
Which purpose the _state_ serves will mainly depend on the _actions_ embedded in the grammar.

An _action_ is a function that, in the definition of the grammar in the C++ source, is associated with a _rule_.
Every time the _rule_ succeeds, the action is invoked with the portion of the _input_ that matched the _rule_.

There are two typical use cases for _actions_.
Either they perform a specific final task while parsing, like in the included `calculator.cc` where the expressions are evaluted by the parser "on the fly" using _actions_.
Or _actions_ can be used to generate an intermediate representation, usually some kind of abstract syntax tree (AST), that is further processed separately, after the parser has finished its job.

An _action_ is attached to a rule by using the `action` class template that takes two template arguments.
The first argument is a _rule_, the second argument is the _action_, which must be a class providing a static `matched` function declared as follows

{{{
   struct my_action
   {
      template< typename Rule >
      static void matched( const std::string & token, ??? );
   };
}}}

where the first string argument contains the portion of the input that the rule attached to the action matched, and the actually used _state_ must be substituted for the `???`.

For example the included `calculator.cc` uses a `std::vector< int >` as stack for the evaluation of (arbitrarily nested) arithmetic expressions.
Whenever the parser recognises (the string representation of) a number, it pushes the number onto the evaluation stack.

{{{
   struct push_action
   {
      template< typename Rule, typename Stack >
      static void matched( const std::string & m, Stack & s )
      {
         s.push_back( utility::string_to_signed< typename Stack::value_type >( m ) );
      }
   };

   struct read_number
         : seq< opt< list< '+', '-' > >, plus< digit > > {};

   struct push_number
         : pad< action< read_number, push_action >, space > {};
}}}

Struct `push_action` is the user-defined action that converts the given string to an integer, and pushes it onto the supplied stack.
Struct `read_number` is a normal _rule_ that recognises decimal numbers with optional sign.
Struct `push_number` contains `action< read_number, push_action >`, which invokes `push_action::matched` every time that `read_number` matched.

The included file `sexpression.cc` shows some further examples.

===Error Messages===

When an error occurs during parsing, i.e. the parser fails for the given input, a parser using the `basic_debug` or `trace_debug` classes as _debug_ will print a backtrace of which rules it was attempting to match at which positions.
Here is the output from the first example program invoked with the -- illegal, since it recognises the regex `[a-zA-Z][a-zA-Z0-9]*` -- input `abc%`.

{{{
  > ./first "abc%"
  pegtl: syntax error at line=1 column=4
  pegtl: nesting # 4 at line=1 column=4 rule digit
  pegtl: nesting # 3 at line=1 column=4 rule ( alpha / digit )
  pegtl: nesting # 2 at line=1 column=2 rule ( ( alpha / digit ) % pegtl::eol )
  pegtl: nesting # 1 at line=1 column=1 rule example::first === ( alpha ( ( alpha / digit ) % pegtl::eol ) )
  pegtl: parsing input from command line argument aborted
  pegtl: parsing aborted at line=1 column=4
}}}

The first line indicates that there was a syntax error, and where the error occurred.
The next line shows the innermost rule that the parser was attempting to match, i.e. the rule where the error was detected, here `digit`.
The following lines show every step of the inductive definition up to the top-level rule, which in this case is `example::first`.
The final two lines show where the error occurred, including where the input came from in the first place, which can be a filename, or, like here, a command line argument.

Rules in error messages are printed in one of two distinct formats, which can be either only the actual expression like `digit`, or `( ( alpha / digit ) % pegtl::eol )`.
Or, the name of the rule class is printed first, followed by `===`, and the actual expression.
The PEGTL automatically collects the name of a rule when the rule was defined as a `struct`, rather than a `typedef`.
Normal rule names include their namespace.

There is also a mechanism that can be used to manually set the name of a rule to an arbitrary value.
This mechanism is used with the PEGTL to give rules like `digit` or `eol` their short names, and is documented in the "Advanced" section below.

=Expressions=

This table shows the principal PEGTL expressions, and their symbolic representation.
The simple rules should be self explaining, the combinators are explained in greater detail below.

|| *Expression* || *Atomic Rule* || *Description* ||
|| || `eof` || Matches end-of-file. ||
|| || `failure` || Always fails. ||
|| || `success` || Always succeeds. ||
|| `.` || `any` || Match any character. ||
|| `"a"` || `one< 'a' >` || Match character. ||
|| `[^a]` || `not_one< 'a' >` || Match any other character. ||
|| `[az]` || `list< 'a', 'z' >` || Match character in list. ||
|| `[^az]` || `not_list< 'a', 'z' >` || Match character not in list. ||
|| `[a-z]` || `range< 'a', 'z' >` || Match character in range. ||
|| `[^a-z]` || `not_range< 'a', 'z' >` || Match character not in range. ||
|| `"hallo"` || `string< 'h', 'a', 'l', 'l', 'o' >` || Match character sequence. ||
|| *Expression* || *Combinator Rule* || *Description* ||
|| `R?` || `opt< R >` || "Optional" ||
|| `R*` || `star< R >` || "Repeat zero-or-more" ||
|| `R+` || `plus< R >` || "Repeat one-or-more" ||
|| `C@` || `until< C >` || PEGTL convenience extension. ||
|| `&C` || `at< C >` || "And-predicate" ||
|| `!C` || `not_at< C >` || "Not-predicate" ||
|| `R T` || `seq< R, T >` || Sequence, or concatenation (variadic). ||
|| `R / T` || `sor< R, T >` || Ordered choice, or sequenced-or (variadic). ||
|| `R % C` || `until< R, C >` || PEGTL convenience extension. ||
|| `R{n}` || `rep< R, n >` || Repeat exactly `n` times" ||
|| `C --> R` || `ifthen< C, R >` || PEGTL convenience extension. ||
|| `C ->> R` || `ifmust< C, R >` || PEGTL convenience extension. ||
|| || `ifthenelse< C, R, T >` || PEGTL convenience extension. ||
|| || `ifmustelse< C, R, T >` || PEGTL convenience extension. ||
|| || `pad< T, L, R = L >` || PEGTL convenience extension. ||
|| || `action< T, F >` || PEGTL way of attaching behaviour to a parsing rule. ||
|| *Expression* || *ASCII Rule* || *Description* ||
|| `"\n` || `lf` || Single line-feed. ||
|| `"\r"` || `cr` || Single carriage-return. ||
|| `"\r\n"` || `crlf` || Combined carriage-return and line-feed. ||
|| `$` || `eol` || Match any end-of-line, including end-of-file. ||
|| `[[:blank:]]` || `blank` || Match space or tab. ||
|| `[[:space:]]` || `space` || Match any white-space. ||
|| `[[:digit:]]` || `digit` || Match any decimal digit. ||
|| `[[:lower:]]` || `lower` || Match any lower-case letter. ||
|| `[[:upper:]]` || `upper` || Match any upper-case letter. ||
|| `[[:alpha:]]` || `alpha` || Match any upper- or lower-case letter. ||
|| `[[:alnum:]]` || `alnum` || Match any upper- or lower-case letter or digit. ||
|| `[[:xdigit:]]` || `xdigit` || Match any hexadecimal digit, upper- or lower-case. ||
|| || `identifier` || Match a C-language identifier (alpha and digits and underscores, no leading digit). ||

Note that the Posix syntax for extended regular expressions is used for the character classes in square brackets.

=Combinators=

Combinators, or operators, are rules that build new expressions from their argument expressions.

===opt< Rule >===

The `opt` template makes `Rule` optional, and therefore always succeeds.

===star< Rule >===

The `star` template repeatedly invokes `Rule` until it fails; the `star` itself always succeeds.

===plus< Rule >===

Semantically equivalent to `seq< Rule, star< Rule > >`.

===sor< Rule, ... >===

The `sor` variadic template can be instantiated with arbitrary many template parameters, including 0 or 1.
It invokes its arguments in order until the first one succeeds, in which case it succeeds itself, or fails if none of the arguments succeed.

This is very much _unlike_ context-free grammars, where the choice combinator is non-deterministic.

===seq< Rule, ... >===

The `seq` variadic template can be instantiated with arbitrary many template parameters, including 0 or 1.
It invokes its arguments in order until the first one fails, in which case it fails itself, or succeeds if all of the arguments succeed.

===at< Rule >===

The `at` template invokes `Rule` and returns its return value, but rewinds the input, i.e. `at` never consumes any input.

===not_at< Rule >===

The `not_at` template invokes `Rule` and returns the negative of its return value, and rewinds the input, i.e. `not_at` never consumes any input.

===must< Rule >===

The `must` template invokes `Rule` and stops the parser when `Rule` fails, even when in an optional context, e.g. `opt< must< Rule > >` or `star< must< Rule > >` both stop the parser when `Rule` fails.

===until1< Cond >===

Semantically equivalent to the recursive `Rule = sor< at< Cond >, seq< any, Rule > >`, but implemented without recursion.

===until< What, Cond >===

Semantically equivalent to the recursive `Rule = sor< at< Cond >, seq< What, Rule > >`, but implemented without recursion.

===rep< Rule, Number >===

Semantically equivalent to `seq< Rule, ..., Rule >` with `Number` repetitions of `Rule`.

===ifthen< Cond, Then >===

Semantically equivalent to `sor< seq< Cond, Then >, not_at< Cond > >`, except for invoking `Cond` only once.

===ifmust< Cond, Then >===

Semantically equivalent to `seq< Cond, must< Then > >`.

===ifthenelse< Cond, Then, Else >===

Semantically equivalent to `sor< seq< Cond, Then >, seq< not_at< Cond >, Else > >`, except for invoking `Cond` only once.

===ifmustelse< Cond, Then, Else >===

Semantically equivalent to `sor< seq< Cond, must< Then > >, seq< not_at< Cond >, must< Else > > >`, except for invoking `Cond` only once.

===pad< Rule, PadL, PadR >===

Semantically equivalent to `seq< star< PadL >, Rule, star< PadR > >`; the `PadR` template argument defaults to `PadL`.

===action< Rule, Func >===

Semantically equivalent to `Rule` with respect to parsing, however on success of `Rule` invokes the static class function `Func::matched( const std::string &, ??? )` with the portion of the input that matched `Rule` as first argument, and forwards any _state_ that was passed to `action` as further arguments. (As in the whole library, C++0x variadic templates and rvalue-references are used to achieve "perfect forwarding" of the _state_ to `Func::matched`.)


=Advanced=

This section covers advanced topics and library internals.

===Examples===

The PEGTL distribution archive contains C++ implementation files that were used during development and debugging of the library itself.
They are included in order to serve as advanced examples on how to create grammars, and in particular how to perform actions while parsing.

===Optimisations===

The PEGTL contains some specialisations of the class templates of its rules that optimise some simple redundancies in the grammar.
For example, `at< at< Rule > >` is transformed into the equivalent `at< Rule >`.

When the macro PEGTL_IMPURE_OPTIMISATIONS is defined, additional template specialisations are enabled that perform optimisations on a grammar that are not always "safe" in the following sense.
The optimisations elide rule invocations that are not necessary for the decision of whether the parser succeeds for any given input.
However, if these rules perform additional operations on the parser state, or have global side-effects, the behaviour will be different compared to the non-optimised version.

For example, `at< star< Rule > >` always succeeds, and can therefore be transformed into `success`; however `at< star< Rule > >` will invoke `Rule` at least once, while `success` will never invoke `Rule`.
The macro can be defined by adding `-DPEGTL_IMPURE_OPTIMISATIONS` to the compiler flags, by changing `pegtl.hh`, or by defining it in the code that includes `pegtl.hh` before the corresponding include preprocessor directive.

===Recursion===

Every rule invocation consists of a function call.
The PEGTL often uses guard-objects in its implementation, which is good C++ style, but unfortunately prevents tail-calls from being optimised.
To prevent a stack overflow, grammars should prefer to use rules for iteration, rather than recursive rules, wherever possible.

This means, in particular, to avoid "head and tail"-style recursion which is used in many functional programming languages.
For example, to express that a `foo` is either empty, or a `bar` followed by a `foo`, we could write the grammar as follows.

{{{
   struct foo
   	 : sor< eof, seq< bar, foo > > {};
}}}

Here every recursive call of `foo` creates a new stack-frame.
A better, equivalent, expression is the following.

{{{
   struct foo
         : until< bar, eof > {};
}}}


===Changelog===

2008-04-03: Changelog starts with PEGTL version 0.9.


=License=

Copyright (c) 2008 Dr. Colin Hirsch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
